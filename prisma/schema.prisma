// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema
// https://www.prisma.io/docs/orm/reference/prisma-schema-reference#string

// Common commands: 
// npx prisma migrate dev

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// by default generated by shopify (after auth)
// this is offline access, which does not expire until the user removes the application
// Before deployment, refactor so that all the database items are connected to the session instead of having its own shop field
model Session {
  id                    String                 @id
  shop                  String
  state                 String
  isOnline              Boolean                @default(false)
  scope                 String?
  expires               DateTime?              @db.Timestamp
  accessToken           String
  userId                BigInt?
  firstName             String?
  lastName              String?
  email                 String?
  accountOwner          Boolean                @default(false)
  locale                String?
  collaborator          Boolean?               @default(false)
  emailVerified         Boolean?               @default(false)
  Role                  Role[]
  Profile               UserProfile?
  ChecklistStatus       ChecklistStatus[]
  UserPreference        UserPreference?
  FulfillmentService    FulfillmentService?
  PriceList             PriceList[]
  ImportedProduct       ImportedProduct[]
  PriceListRetailer     PriceListRetailer[]
  RetailerPartnership   Partnership[]          @relation("RetailerPartnership")
  SupplierPartnership   Partnership[]          @relation("SupplierPartnership")
  SupplierAccessRequest SupplierAccessRequest?
}

model FulfillmentService {
  id                   String  @id @default(uuid())
  fulfillmentServiceId String
  Session              Session @relation(fields: [sessionId], references: [id])
  sessionId            String  @unique
}

model UserPreference {
  id             String   @id @default(uuid())
  session        Session  @relation(fields: [sessionId], references: [id])
  tableIdsHidden String[]
  sessionId      String   @unique
}

model ChecklistTable {
  id             String          @id @default(uuid())
  position       Int
  header         String
  subheader      String?
  checklistItems ChecklistItem[]
}

model ChecklistItem {
  id               String            @id @default(uuid())
  key              String            @unique
  ChecklistTable   ChecklistTable    @relation(fields: [checklistTableId], references: [id])
  checklistTableId String
  position         Int
  header           String
  subheader        String?
  buttonText       String?
  checklistStatus  ChecklistStatus[]
}

model ChecklistStatus {
  id                    String                 @id @default(uuid())
  Session               Session                @relation(fields: [sessionId], references: [id])
  sessionId             String
  ChecklistItem         ChecklistItem          @relation(fields: [checklistItemId], references: [id])
  checklistItemId       String
  isCompleted           Boolean
  SupplierAccessRequest SupplierAccessRequest?
}

model Role {
  id                 String   @id @default(uuid())
  name               String
  Session            Session  @relation(fields: [sessionId], references: [id])
  sessionId          String
  createdAt          DateTime @default(now())
  isVisibleInNetwork Boolean  @default(true)
}

model UserProfile {
  id              String           @id @default(uuid())
  name            String
  website         String
  address         String?
  email           String
  logo            String?
  biography       String?
  desiredProducts String?
  Session         Session          @relation(fields: [sessionId], references: [id])
  sessionId       String           @unique
  SocialMediaLink SocialMediaLink?
}

model SocialMediaLink {
  id            String      @id @default(uuid())
  facebook      String      @default("")
  twitter       String      @default("")
  instagram     String      @default("")
  youtube       String      @default("")
  tiktok        String      @default("")
  UserProfile   UserProfile @relation(fields: [userProfileId], references: [id])
  userProfileId String      @unique
}

// Supplier and Retailer Functionality
// Price list and product
model PriceList {
  id                       String              @id @default(uuid())
  createdAt                DateTime            @default(now())
  name                     String
  isGeneral                Boolean // There can only be one general price list, this is what products are visible on the products page
  requiresApprovalToImport Boolean? // if the price list is a general price list, suppliers can decide whether or not retailers have to request permission to import their products
  pricingStrategy          String
  Session                  Session             @relation(fields: [supplierId], references: [id])
  supplierId               String
  margin                   Int?
  Product                  Product[]
  PriceListRetailer        PriceListRetailer[]
}

// Keeps track of the retailers in the price list
model PriceListRetailer {
  id          String    @id @default(uuid())
  PriceList   PriceList @relation(fields: [priceListId], references: [id])
  priceListId String
  Session     Session   @relation(fields: [retailerId], references: [id])
  retailerId  String
}

model Product {
  id              String            @id @default(uuid())
  productId       String
  categoryId      String?
  productType     String
  description     String
  descriptionHtml String
  status          String
  vendor          String
  title           String
  PriceList       PriceList         @relation(fields: [priceListId], references: [id])
  priceListId     String
  ImportedProduct ImportedProduct[]
  Image           Image[]
}

model Image {
  id               String  @id @default(uuid())
  Product          Product @relation(fields: [productId], references: [id])
  productId        String
  url              String
  alt              String
  mediaContentType String
  position         Int
}

model ImportedProduct {
  id                         String                       @id @default(uuid())
  Product                    Product                      @relation(fields: [productId], references: [id])
  productId                  String
  Session                    Session                      @relation(fields: [retailerId], references: [id])
  retailerId                 String
  importedAt                 DateTime                     @default(now())
  ImportedProductTransaction ImportedProductTransaction[]
}

model ImportedProductTransaction {
  id                String          @id @default(uuid())
  ImportedProduct   ImportedProduct @relation(fields: [importedProductId], references: [id])
  importedProductId String
  createdAt         DateTime
  fulfilledAt       DateTime
  // TODO: figure out what fields I need to add
  unitSales         Int
}

model Partnership {
  id         String  @id @default(uuid())
  retailerId String
  supplierId String
  retailer   Session @relation("RetailerPartnership", fields: [retailerId], references: [id])
  supplier   Session @relation("SupplierPartnership", fields: [supplierId], references: [id])
}

model SupplierAccessRequest {
  id                      String          @id @default(uuid())
  num                     Int             @default(autoincrement())
  ChecklistStatus         ChecklistStatus @relation(fields: [checklistStatusId], references: [id])
  checklistStatusId       String          @unique
  hasMetSalesThreshold    Boolean
  createdAt               DateTime        @default(now())
  updatedAt               DateTime        @default(now())
  status                  String
  Session                 Session         @relation(fields: [sessionId], references: [id])
  sessionId               String          @unique
  notes                   String?
  isEligibleForNewRequest Boolean         @default(true) // This variable is just in case we reject a supplier and they are not allowed to relist on our app
}
