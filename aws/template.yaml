AWSTemplateFormatVersion: "2010-09-09"
Transform:
  - AWS::Serverless-2016-10-31
  - AWS::LanguageExtensions
Description: >
  SAM Template For all infrastructure for SynqSell

# Helpful Links
# https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/pseudo-parameter-reference.html
# commands
# sam build
# sam validate
# sam deploy --config-env default
# sam deploy --config-env prod

# TODO: Add lambda layers for shared functions
# TODO: Create a CD pipeline to automatically build and push the docker image onto ECR, and pull/run the docker image from ECR to EC2
# TODO: Add db password rotation for added security
# TODO: Read about common file structure organizations of CloudFormation / Terraform to figure out how to organize this IaC into multiple files
# Current impl is dev env is only local development (just use ngrok for viewing data streaming, etc.)
# We do not need staging branch for now, we would need it when we have our first users

Parameters:
  Environment:
    Type: String
    Default: dev
    AllowedValues:
      - dev
      - prod
    Description: The environment of the deployment

Conditions:
  isProd: !Equals
    - !Ref Environment
    - prod

Globals:
  Api:
    Cors:
      AllowMethods: "'POST,OPTIONS'"
      AllowHeaders: "'Content-Type,X-Shopify-Shop-Domain,X-Shopify-Hmac-SHA256'"
      AllowOrigin: "'https://*.myshopify.com'"
      MaxAge: "'300'"
  Function:
    Timeout: 3
    Environment:
      Variables:
        DB_USER_CREDENTIALS_SECRET_ID: !Ref DatabaseUserCredentialSecret # secret-id can be either the arn or id, doesn't matter
        DB_CONNECTION_SECRET_ID: !Ref DatabaseConnectionSecret
        API_KEYS_SECRET_ID: !Sub ${Environment}/apiKeys
    LoggingConfig:
      LogFormat: JSON
    VpcConfig:
      SecurityGroupIds:
        - !Ref LambdaSecurityGroup
      SubnetIds:
        - !Ref PrivateSubnetOne
        - !Ref PrivateSubnetTwo

Resources:
  # VPC Configuration
  MyVPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsHostnames: true
      EnableDnsSupport: true
      InstanceTenancy: default

  InternetGateway:
    Type: AWS::EC2::InternetGateway

  GatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref MyVPC
      InternetGatewayId: !Ref InternetGateway

  PrivateSubnetOne:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref MyVPC
      CidrBlock: !Select [0, !Cidr [!GetAtt MyVPC.CidrBlock, 3, 8]]
      MapPublicIpOnLaunch: false
      AvailabilityZone: !Select [0, !GetAZs ""]

  PrivateSubnetTwo:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref MyVPC
      CidrBlock: !Select [1, !Cidr [!GetAtt MyVPC.CidrBlock, 3, 8]]
      MapPublicIpOnLaunch: false
      AvailabilityZone: !Select [1, !GetAZs ""]

  PublicSubnetOne:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref MyVPC
      MapPublicIpOnLaunch: True
      CidrBlock: !Select [2, !Cidr [!GetAtt MyVPC.CidrBlock, 3, 8]]
      AvailabilityZone: !Select [0, !GetAZs ""]

  PublicSubnetTwo:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref MyVPC
      CidrBlock: !Select [3, !Cidr [!GetAtt MyVPC.CidrBlock, 4, 8]]
      MapPublicIpOnLaunch: false
      AvailabilityZone: !Select [1, !GetAZs ""]

  # Resources for Application
  ImageHostingS3:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "{{resolve:secretsmanager:${Environment}/appConfig:SecretString:s3BucketName}}"
      PublicAccessBlockConfiguration:
        BlockPublicAcls: false
        BlockPublicPolicy: false
        IgnorePublicAcls: false
        RestrictPublicBuckets: false
    Metadata:
      Description: "Public S3 bucket for hosting publicly accessible images such logos for SynqSell"

  ImageHostingS3BucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref ImageHostingS3
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: PublicReadGetObject
            Effect: Allow
            Principal: "*"
            Action: s3:GetObject
            Resource: !Sub arn:aws:s3:::${ImageHostingS3}/*

  # Related to web/app browser
  # Flow is Internet => ALB Listener => Target Group => EC2 Instances
  # Note: we only need an ALB and EC2 for staging and prod
  ALBSecurityGroup:
    Type: "AWS::EC2::SecurityGroup"
    Condition: isProd
    Properties:
      GroupDescription: "Security group for ALB"
      VpcId: !Ref MyVPC
      SecurityGroupIngress:
        - CidrIp: "0.0.0.0/0"
          FromPort: 80
          IpProtocol: "tcp"
          ToPort: 80
        - CidrIp: "0.0.0.0/0"
          FromPort: 443
          IpProtocol: "tcp"
          ToPort: 443

  ApplicationLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Condition: isProd
    Properties:
      Name: !Sub "${Environment}-alb"
      Scheme: "internet-facing"
      Type: "application"
      Subnets:
        - !Ref PublicSubnetOne
        - !Ref PublicSubnetTwo
      SecurityGroups:
        - !Ref ALBSecurityGroup
      IpAddressType: "ipv4"

  # DNSRecord:
  #   Type: AWS::Route53::RecordSet
  #   Condition: isProd
  #   Properties:
  #     HostedZoneId: !Sub "{{resolve:secretsmanager:${Environment}/appConfig:SecretString:appHostedZoneId}}"
  #     Name: !Sub "{{resolve:secretsmanager:${Environment}/appConfig:SecretString:appDomainName}}."
  #     Type: A
  #     AliasTarget:
  #       DNSName: !GetAtt ApplicationLoadBalancer.DNSName
  #       HostedZoneId: !GetAtt ApplicationLoadBalancer.CanonicalHostedZoneID
  #       EvaluateTargetHealth: true

  ALBCertificate:
    Type: AWS::CertificateManager::Certificate
    Condition: isProd
    Properties:
      ValidationMethod: DNS
      DomainName: !Sub "{{resolve:secretsmanager:${Environment}/appConfig:SecretString:appDomainName}}"

  # listener basically listens to requests and passes it securely to load balancer
  HTTPListener:
    Type: "AWS::ElasticLoadBalancingV2::Listener"
    Condition: isProd
    Properties:
      LoadBalancerArn: !Ref ApplicationLoadBalancer
      Port: 80
      Protocol: "HTTP"
      DefaultActions:
        - Order: 1
          RedirectConfig:
            Protocol: "HTTPS"
            Port: "443"
            Host: "#{host}"
            Path: "/#{path}"
            Query: "#{query}"
            StatusCode: "HTTP_301"
          Type: "redirect"

  HTTPSListener:
    Type: "AWS::ElasticLoadBalancingV2::Listener"
    Condition: isProd
    Properties:
      Certificates:
        - !Ref ALBCertificate
      LoadBalancerArn: !Ref ApplicationLoadBalancer
      Port: 443
      Protocol: "HTTPS"
      SslPolicy: "ELBSecurityPolicy-2016-08"
      DefaultActions:
        - Order: 1
          TargetGroupArn: !Ref TargetGroupOne
          Type: "forward"

  TargetGroupOne:
    Type: "AWS::ElasticLoadBalancingV2::TargetGroup"
    Condition: isProd
    Properties:
      Port: 80
      Protocol: "HTTP"
      VpcId: !Ref MyVPC
      Targets:
        - Id: !Ref RemixAppInstance

  ECR:
    Type: AWS::ECR::Repository
    Condition: isProd
    Properties:
      EmptyOnDelete: True
      RepositoryName: !Sub ${Environment}/synqsell
      ImageScanningConfiguration:
        ScanOnPush: true
      ImageTagMutability: IMMUTABLE

  RemixAppInstanceRole:
    Type: AWS::IAM::Role
    Condition: isProd
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: ECRAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: ecr:GetAuthorizationToken
                Resource: "*"
              - Effect: Allow
                Action:
                  - ecr:BatchGetImage
                  - ecr:GetDownloadUrlForLayer
                  - ecr:BatchCheckLayerAvailability
                Resource: !GetAtt ECR.Arn

  # You must have a profile to attach a role to an EC2
  RemixAppInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Condition: isProd
    Properties:
      InstanceProfileName: !Sub ${Environment}-remix-app-ec2-instance-profile
      Path: /
      Roles:
        - !Ref RemixAppInstanceRole

  RemixAppSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Condition: isProd
    Properties:
      GroupDescription: Security group for Remix Application on EC2
      VpcId: !Ref MyVPC
      SecurityGroupIngress:
        - IpProtocol: tcp # HTTP
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp # HTTPS
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp # SSH
          FromPort: 22
          ToPort: 22
          CidrIp: !Sub "{{resolve:secretsmanager:${Environment}/appConfig:SecretString:myCidrIP}}"

  RemixAppInstance:
    Type: AWS::EC2::Instance
    Condition: isProd
    Properties:
      ImageId: ami-037774efca2da0726
      InstanceType: t2.micro
      NetworkInterfaces:
        - AssociatePublicIpAddress: "true"
          DeviceIndex: "0"
          GroupSet:
            - !Ref RemixAppSecurityGroup
          SubnetId: !Ref PrivateSubnetOne
      KeyName: !Sub "{{resolve:secretsmanager:${Environment}/appConfig:SecretString:webAppKeyPair}}"
      IamInstanceProfile: !Ref RemixAppInstanceProfile

  # https://aws.amazon.com/blogs/security/how-to-securely-provide-database-credentials-to-lambda-functions-by-using-aws-secrets-manager/#:~:text=Dynamic%20references%20provide%20a%20compact%2C%20powerful%20way%20for,the%20resolved%20value%2C%20keeping%20the%20database%20password%20safe.
  DatabaseUserCredentialSecret:
    Type: AWS::SecretsManager::Secret
    DeletionPolicy: Delete
    Name: !Sub "${Environment}/databaseUserCredentials"
    UpdateReplacePolicy: Delete
    Properties:
      Description: RDS Master User Credentials
      GenerateSecretString:
        SecretStringTemplate: !Sub
          - '{"username": "${username}"}'
          - username: !Sub "{{resolve:secretsmanager:${Environment}/appConfig:SecretString:dbUsername}}"
        GenerateStringKey: "password"
        PasswordLength: 16
        ExcludeCharacters: "\"'`|;:,!@#$%^&*()<>[]{}/?~\\"

  DatabaseRDS:
    Type: AWS::RDS::DBInstance
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      DBName: !Sub "{{resolve:secretsmanager:${Environment}/appConfig:SecretString:dbName}}"
      Engine: "postgres"
      MasterUsername: !Sub "{{resolve:secretsmanager:${DatabaseUserCredentialSecret}:SecretString:username}}"
      MasterUserPassword: !Sub "{{resolve:secretsmanager:${DatabaseUserCredentialSecret}:SecretString:password}}"
      Port: "5432"
      DBInstanceClass: "db.t3.micro"
      AllocatedStorage: "20"
      PubliclyAccessible: false
      BackupRetentionPeriod: 7
      MultiAZ: false
      DBSubnetGroupName: !Ref DatabaseSubnets
      VPCSecurityGroups:
        - !GetAtt DatabaseSecurityGroup.GroupId

  DatabaseConnectionSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub "${Environment}/databaseConnection"
      Description: RDS Connection information
      SecretString: !Sub
        - '{"database": "${database}", "host": "${host}", "port": "${port}"}'
        - database: !Sub "{{resolve:secretsmanager:${Environment}/appConfig:SecretString:dbName}}"
          host: !GetAtt DatabaseRDS.Endpoint.Address
          port: !GetAtt DatabaseRDS.Endpoint.Port

  DatabaseSubnets:
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupDescription: Subnet group for RDS instance
      SubnetIds:
        - !Ref PrivateSubnetOne
        - !Ref PrivateSubnetTwo

  # Need a Bastion host in public subnet for backend development, TODO: research if I can just use VPN for local development, and bastion host for prod, so I don't have an extra EC2 running
  BastionHostSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for Bastion host
      VpcId: !Ref MyVPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: !Sub "{{resolve:secretsmanager:${Environment}/appConfig:SecretString:myCidrIP}}"

  DatabaseSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for database access
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 5432
          ToPort: 5432
          SourceSecurityGroupId: !Ref LambdaSecurityGroup
        - IpProtocol: tcp
          FromPort: 5432
          ToPort: 5432
          SourceSecurityGroupId: !Ref BastionHostSecurityGroup
      VpcId: !Ref MyVPC

  BastionHost:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: ami-037774efca2da0726
      InstanceType: t2.micro
      NetworkInterfaces:
        - AssociatePublicIpAddress: "true"
          DeviceIndex: "0"
          GroupSet:
            - !Ref BastionHostSecurityGroup
          SubnetId: !Ref PublicSubnetOne
      KeyName: !Sub "{{resolve:secretsmanager:${Environment}/appConfig:SecretString:bastionHostKeyPair}}"

  # Start routing to give lambda functions access to internet via NAT Gateway
  LambdaSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for Lambda functions
      VpcId: !Ref MyVPC

  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref MyVPC

  PublicRoute:
    Type: AWS::EC2::Route
    DependsOn: GatewayAttachment
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  PublicSubnetOneTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnetOne
      RouteTableId: !Ref PublicRouteTable

  PublicSubnetTwoTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnetTwo
      RouteTableId: !Ref PublicRouteTable

  NATGateway:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt NATGatewayEIP.AllocationId
      SubnetId: !Ref PublicSubnetOne
      Tags:
        - Key: Name
          Value: NATGateway

  NATGatewayEIP:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc

  PrivateRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref MyVPC

  PrivateSubnetOneTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PrivateSubnetOne
      RouteTableId: !Ref PrivateRouteTable

  PrivateSubnetTwoTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PrivateSubnetTwo
      RouteTableId: !Ref PrivateRouteTable

  PrivateRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NATGateway

  # Start API Gateway
  # https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-integration-types.html
  # https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-control-access-using-iam-policies-to-invoke-api.html
  APIGatewayCloudWatchRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - apigateway.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs

  ApiGatewayAccount:
    Type: AWS::ApiGateway::Account
    Properties:
      CloudWatchRoleArn: !GetAtt APIGatewayCloudWatchRole.Arn

  APIGateway:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Join ["_", [!Sub "${Environment}", APIGateway]]

  DeliveryCarrierServiceApiResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt APIGateway.RootResourceId
      RestApiId: !Ref APIGateway
      PathPart: deliveryCarrierService

  DeliveryCarrierServiceCallback:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !Ref DeliveryCarrierServiceApiResource
      RestApiId: !Ref APIGateway
      PathPart: callback

  DeliveryCarrierServiceApiMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      ResourceId: !Ref DeliveryCarrierServiceCallback
      RestApiId: !Ref APIGateway
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${DeliveryCarrierServiceFunction.Arn}/invocations

  DeliveryCarrierServicePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref DeliveryCarrierServiceFunction
      Action: "lambda:InvokeFunction"
      Principal: "apigateway.amazonaws.com"
      SourceArn: !Sub
        - arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiId}/*/${HttpMethod}/${ResourcePath}
        - ApiId: !Ref APIGateway
          HttpMethod: POST
          ResourcePath: !Join ["/", ["deliveryCarrierService", "callback"]]

  DeliveryCarrierServiceFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName:
        !Join ["_", [!Sub "${Environment}", delivery_carrier_service]]
      CodeUri: shopify/api/deliveryCarrierService/
      Handler: app.lambdaHandler
      MemorySize: 1028
      Timeout: 30
      Runtime: nodejs20.x
      Architectures:
        - x86_64
    Metadata:
      BuildMethod: esbuild
      BuildProperties:
        Minify: true
        Target: es2020
        Sourcemap: false
        EntryPoints:
          - app.ts

  # For the Stripe Public Endpoint
  # Stripe EventBridge is in closed beta, the only way to handle right now is by creating a public endpoint
  StripeServiceApiResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt APIGateway.RootResourceId
      RestApiId: !Ref APIGateway
      PathPart: stripe

  StripeWebhooksApiResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !Ref StripeServiceApiResource
      RestApiId: !Ref APIGateway
      PathPart: webhooks

  # Policies for lambda functions
  LambdaInvokePolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: "Policy for invoking Lambda functions"
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - "lambda:InvokeFunction"
            Resource: "*"

  ApiKeyAccessPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: "Policy for accessing secrets"
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - "secretsmanager:GetSecretValue"
            Resource:
              - !Sub
                - "arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${SecretId}-*"
                - SecretId: !Sub ${Environment}/apiKeys
              - !Ref DatabaseConnectionSecret
              - !Ref DatabaseUserCredentialSecret

  PrivateFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Ref ApiKeyAccessPolicy
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole

  CoordinatorFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Ref LambdaInvokePolicy
        - !Ref ApiKeyAccessPolicy
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole

  StripeWebhookCoordinatorFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName:
        !Join ["_", [!Sub "${Environment}", stripe_webhook_coordinator]]
      CodeUri: stripe/webhooks/webhooksCoordinator/
      Handler: app.lambdaHandler
      MemorySize: 1028
      Timeout: 30
      Runtime: nodejs20.x
      Architectures:
        - x86_64
      Role: !GetAtt CoordinatorFunctionRole.Arn
    Metadata:
      BuildMethod: esbuild
      BuildProperties:
        Minify: true
        Target: es2020
        Sourcemap: false
        EntryPoints:
          - app.ts

  StripeLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref StripeWebhookCoordinatorFunction
      Action: "lambda:InvokeFunction"
      Principal: "apigateway.amazonaws.com"
      SourceArn: !Sub
        - arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiId}/*/${HttpMethod}/${ResourcePath}
        - ApiId: !Ref APIGateway
          HttpMethod: POST
          ResourcePath: !Join ["/", ["stripe", "webhooks"]]

  StripeApiMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      ResourceId: !Ref StripeWebhooksApiResource
      RestApiId: !Ref APIGateway
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${StripeWebhookCoordinatorFunction.Arn}/invocations

  # https://medium.com/@lancers/deployment-in-amazon-api-gateway-128c522c762e
  # There should be other ways to handle this issue, but deployments are deployed snapshots so unless you delete / recreate the resource, it will not redeploy...
  # For now, follow the solution in the medium article above, but either switch to v2 with AutoDeploy property or decide how to do it later
  APIGatewayStage:
    Type: AWS::ApiGateway::Stage
    Properties:
      DeploymentId: !Ref APIGatewayDeployment20241018
      RestApiId: !Ref APIGateway
      StageName: dev

  APIGatewayDeployment20241018:
    Type: AWS::ApiGateway::Deployment
    Properties:
      RestApiId: !Ref APIGateway
    DependsOn:
      - DeliveryCarrierServiceApiMethod
      - StripeApiMethod

  # End of API Gateway Deployment

  # https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html
  # for queue to ensure retry mechanism for webhook delivery
  WebhookSQS:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Join ["_", [!Sub "${Environment}", "webhook_queue.fifo"]]
      FifoQueue: true
      ContentBasedDeduplication: true
      RedrivePolicy:
        deadLetterTargetArn: !GetAtt WebhookDLQ.Arn
        maxReceiveCount: 3

  ShopifyWebhookRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Join ["_", [!Sub "${Environment}", shopify_sqs_rule]]
      EventPattern:
        detail-type:
          - "shopifyWebhook"
        detail:
          metadata:
            X-Shopify-Topic:
              - prefix: ""
      EventBusName: !Sub
        - "arn:aws:events:${AWS::Region}:${AWS::AccountId}:event-bus/${identifier}"
        - identifier: !Sub "{{resolve:secretsmanager:${Environment}/appConfig:SecretString:shopifyEventBusIdentifier}}"

      Targets:
        - Arn: !GetAtt WebhookSQS.Arn
          Id: "WebhookSQSTarget"
          SqsParameters:
            MessageGroupId: "ShopifyWebhookMessages"

  EventBridgeSQSPolicy:
    Type: AWS::SQS::QueuePolicy
    Properties:
      Queues:
        - !Ref WebhookSQS
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: events.amazonaws.com
            Action:
              - "SQS:SendMessage"
            Resource: !GetAtt WebhookSQS.Arn
            Condition:
              ArnEquals:
                aws:SourceArn: !GetAtt ShopifyWebhookRule.Arn

  WebhookDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName:
        !Join ["_", [!Sub "${Environment}", "webhook_dead_letter_queue.fifo"]]
      FifoQueue: true
      ContentBasedDeduplication: true

  # Coordinator Lambda Function that invokes lambda functions for handling shopify webhook topics
  CoordinatorFunctionExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      Policies:
        - PolicyName: SQSAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - sqs:ReceiveMessage
                  - sqs:DeleteMessage
                  - sqs:GetQueueAttributes
                Resource: !GetAtt WebhookSQS.Arn
        - PolicyName: LambdaInvokePolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource: "*"

  CoordinatorFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Join ["_", [!Sub "${Environment}", webhooks_coordinator]]
      CodeUri: shopify/webhooks/webhooksCoordinator/
      Handler: app.lambdaHandler
      MemorySize: 1028
      Timeout: 30
      Runtime: nodejs20.x
      Role: !GetAtt CoordinatorFunctionExecutionRole.Arn
      Architectures:
        - x86_64
    Metadata:
      BuildMethod: esbuild
      BuildProperties:
        Minify: true
        Target: es2020
        Sourcemap: false
        EntryPoints:
          - app.ts
  SQSQueueTrigger:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      EventSourceArn: !GetAtt WebhookSQS.Arn
      FunctionName: !Ref CoordinatorFunction
      Enabled: true

  # Start Lambda Functions For Handling Shopify Webhooks
  DeleteProductsFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Join ["_", [!Sub "${Environment}", "products_delete"]]
      CodeUri: shopify/webhooks/deleteProducts/
      Handler: app.lambdaHandler
      MemorySize: 1028
      Timeout: 30
      Runtime: nodejs20.x
      Architectures:
        - x86_64
      Role: !GetAtt PrivateFunctionRole.Arn
    Metadata:
      BuildMethod: esbuild
      BuildProperties:
        Minify: true
        Target: es2020
        Sourcemap: false
        EntryPoints:
          - app.ts

  ProductsUpdateFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Join ["_", [!Sub "${Environment}", "products_update"]]
      CodeUri: shopify/webhooks/productsUpdate/
      Handler: app.lambdaHandler
      MemorySize: 1028
      Timeout: 30
      Runtime: nodejs20.x
      Architectures:
        - x86_64
      Role: !GetAtt PrivateFunctionRole.Arn
    Metadata:
      BuildMethod: esbuild
      BuildProperties:
        Minify: true
        Target: es2020
        Sourcemap: false
        EntryPoints:
          - app.ts

  FulfillmentOrderRoutingCompleteFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName:
        !Join ["_", [!Sub "${Environment}", "order_routing_complete"]]
      CodeUri: shopify/webhooks/fulfillmentOrdersOrderRoutingComplete/
      Handler: app.lambdaHandler
      MemorySize: 1028
      Timeout: 30
      Runtime: nodejs20.x
      Architectures:
        - x86_64
      Role: !GetAtt PrivateFunctionRole.Arn
    Metadata:
      BuildMethod: esbuild
      BuildProperties:
        Minify: true
        Target: es2020
        Sourcemap: false
        EntryPoints:
          - app.ts

  # fulfillments/create webhook
  FulfillmentsCreateFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Join ["_", [!Sub "${Environment}", "fulfillments_create"]]
      CodeUri: shopify/webhooks/fulfillmentsCreate/
      Handler: app.lambdaHandler
      MemorySize: 1028
      Timeout: 30
      Runtime: nodejs20.x
      Architectures:
        - x86_64
      Role: !GetAtt PrivateFunctionRole.Arn
    Metadata:
      BuildMethod: esbuild
      BuildProperties:
        Minify: true
        Target: es2020
        Sourcemap: false
        EntryPoints:
          - app.ts

  OrdersCancelledFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Join ["_", [!Sub "${Environment}", "orders_cancelled"]]
      CodeUri: shopify/webhooks/ordersCancelled/
      Handler: app.lambdaHandler
      MemorySize: 1028
      Timeout: 30
      Runtime: nodejs20.x
      Architectures:
        - x86_64
      Role: !GetAtt PrivateFunctionRole.Arn
    Metadata:
      BuildMethod: esbuild
      BuildProperties:
        Minify: true
        Target: es2020
        Sourcemap: false
        EntryPoints:
          - app.ts

  FulfillmentsUpdateFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Join ["_", [!Sub "${Environment}", "fulfillments_update"]]
      CodeUri: shopify/webhooks/fulfillmentsUpdate/
      Handler: app.lambdaHandler
      MemorySize: 1028
      Timeout: 30
      Runtime: nodejs20.x
      Architectures:
        - x86_64
      Role: !GetAtt PrivateFunctionRole.Arn
    Metadata:
      BuildMethod: esbuild
      BuildProperties:
        Minify: true
        Target: es2020
        Sourcemap: false
        EntryPoints:
          - app.ts

  AppUninstalledFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Join ["_", [!Sub "${Environment}", "app_uninstalled"]]
      CodeUri: shopify/webhooks/appUninstalled/
      Handler: app.lambdaHandler
      MemorySize: 1028
      Timeout: 30
      Runtime: nodejs20.x
      Architectures:
        - x86_64
      Role: !GetAtt PrivateFunctionRole.Arn
    Metadata:
      BuildMethod: esbuild
      BuildProperties:
        Minify: true
        Target: es2020
        Sourcemap: false
        EntryPoints:
          - app.ts

  ShopRedactFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Join ["_", [!Sub "${Environment}", "shop_redact"]]
      CodeUri: shopify/webhooks/shopRedact/
      Handler: app.lambdaHandler
      MemorySize: 1028
      Timeout: 30
      Runtime: nodejs20.x
      Architectures:
        - x86_64
      Role: !GetAtt PrivateFunctionRole.Arn
    Metadata:
      BuildMethod: esbuild
      BuildProperties:
        Minify: true
        Target: es2020
        Sourcemap: false
        EntryPoints:
          - app.ts

  # mandatory GDPR compliance webhooks
  CustomersDataRequestFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName:
        !Join ["_", [!Sub "${Environment}", "customers_data_request"]]
      CodeUri: shopify/webhooks/customersDataRequest/
      Handler: app.lambdaHandler
      MemorySize: 1028
      Timeout: 30
      Runtime: nodejs20.x
      Architectures:
        - x86_64
      Role: !GetAtt PrivateFunctionRole.Arn
    Metadata:
      BuildMethod: esbuild
      BuildProperties:
        Minify: true
        Target: es2020
        Sourcemap: false
        EntryPoints:
          - app.ts

  CustomersRedactFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Join ["_", [!Sub "${Environment}", "customers_redact"]]
      CodeUri: shopify/webhooks/customersRedact/
      Handler: app.lambdaHandler
      MemorySize: 1028
      Timeout: 30
      Runtime: nodejs20.x
      Architectures:
        - x86_64
      Role: !GetAtt PrivateFunctionRole.Arn
    Metadata:
      BuildMethod: esbuild
      BuildProperties:
        Minify: true
        Target: es2020
        Sourcemap: false
        EntryPoints:
          - app.ts

  # Stripe webhook topics
  StripeAccountApplicationDeauthorizedFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName:
        !Join [
          "_",
          [!Sub "${Environment}", "stripe_account_application_deauthorized"],
        ]
      CodeUri: stripe/webhooks/accountApplicationDeauthorized/
      Handler: app.lambdaHandler
      MemorySize: 1028
      Timeout: 30
      Runtime: nodejs20.x
      Architectures:
        - x86_64
      Role: !GetAtt PrivateFunctionRole.Arn
    Metadata:
      BuildMethod: esbuild
      BuildProperties:
        Minify: true
        Target: es2020
        Sourcemap: false
        EntryPoints:
          - app.ts

  StripePaymentMethodDetached:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName:
        !Join ["_", [!Sub "${Environment}", "stripe_payment_method_detached"]]
      CodeUri: stripe/webhooks/paymentMethodDetached/
      Handler: app.lambdaHandler
      MemorySize: 1028
      Timeout: 30
      Runtime: nodejs20.x
      Architectures:
        - x86_64
      Role: !GetAtt PrivateFunctionRole.Arn
    Metadata:
      BuildMethod: esbuild
      BuildProperties:
        Minify: true
        Target: es2020
        Sourcemap: false
        EntryPoints:
          - app.ts

Outputs:
  s3Bucket:
    Description: S3 bucket name for storing all the merchants' logos
    Value: !Ref ImageHostingS3
  awsRegion:
    Description: AWS Region of Deployed Resources
    Value: !Ref AWS::Region
  dbUserSecretArn:
    Description: Secrets Manager for Database Admin User Credentials
    Value: !GetAtt DatabaseUserCredentialSecret.Id
  dbConnectionSecretArn:
    Description: Secrets Manager for Database Connection
    Value: !GetAtt DatabaseConnectionSecret.Id
  bastionHostPublicIP:
    Description: Public IP of your bastion host
    Value: !GetAtt BastionHost.PublicIp
  deliveryServiceCallbackUrl:
    Description: The public callback endpoint for calculating shipping rates on Shopify
    Value: !Sub
      - https://${ApiID}.execute-api.${AWS::Region}.amazonaws.com/dev/deliveryCarrierService/callback
      - ApiID: !Ref APIGateway
  stripeWebhookUrl:
    Description: The public endpoint for coordinating all stripe webhooks
    Value: !Sub
      - https://${ApiID}.execute-api.${AWS::Region}.amazonaws.com/dev/stripe/webhooks
      - ApiID: !Ref APIGateway
  albDNSName:
    Condition: isProd
    Description: The application url to set SynqSell
    Value: !GetAtt ApplicationLoadBalancer.DNSName
